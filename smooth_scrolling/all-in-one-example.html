<!-- SMOOTH SCROLLING - ALL-IN-ONE VERSION -->
<!-- Copy this entire block into a T123 HTML block -->

<link rel="stylesheet" href="https://unpkg.com/lenis@1.3.3/dist/lenis.css">
<script src="https://unpkg.com/lenis@1.3.3/dist/lenis.min.js"></script>

<style>
/* ===== SMOOTH SCROLLING COMPONENT STYLES ===== */

/* Reset default scroll behavior to let Lenis handle it */
html {
    scroll-behavior: initial !important;
}
</style>

<script>
// Smooth Scrolling Component with Lenis
// Provides adaptive smooth scrolling that adjusts based on input device
(function() {
    'use strict';

    let smoothEnabled = true;
    let lastInput = 'mouse';
    let currentInputMode = 'mouse'; // Track current mode for immediate prevention

    const detector = {
        detect(e) {
            let method = 'unknown';
            
            if (e.type === 'wheel') {
                const { deltaX, deltaY } = e;
                const absY = Math.abs(deltaY);
                const absX = Math.abs(deltaX);

                // More aggressive mouse detection for immediate response
                if (absY > 50 || (absX === 0 && absY > 20)) method = 'mouse';
                else if (absX > 2) method = 'trackpad';
                else if (absY < 15 && e.deltaMode === 0) method = 'trackpad';
                else method = absY > 30 ? 'mouse' : 'trackpad';

                // Update current mode immediately
                currentInputMode = method;
            } else if (e.type.startsWith('pointer')) {
                method = e.pointerType === 'mouse' ? 'mouse' : 'touch';
                currentInputMode = method;
            } else if (e.type.startsWith('touch')) {
                method = 'touch';
                currentInputMode = method;
            }

            if (method !== 'unknown' && method !== lastInput) {
                lastInput = method;
                this.update(method);
            }
        },

        update(method) {
            const shouldSmooth = method === 'mouse';
            if (shouldSmooth === smoothEnabled) return;
            
            smoothEnabled = shouldSmooth;
            const controller = window.TildaController?.getInstance();
            if (!controller) return;

            if (!controller.stoppedByPopup && controller.lenis) {
                if (shouldSmooth) {
                    // More responsive settings for mouse to reduce bounce
                    controller.lenis.options.lerp = 0.08; // Balanced response
                    controller.lenis.options.smoothWheel = true;
                } else {
                    // Instant for trackpad
                    controller.lenis.options.lerp = 1;
                    controller.lenis.options.smoothWheel = false;
                }
            }
            controller.updatePopups();
        },

        init() {
            document.addEventListener('wheel', e => this.detect(e), { passive: true });
            document.addEventListener('pointerdown', e => this.detect(e), { passive: true });
            document.addEventListener('touchstart', e => this.detect(e), { passive: true });
        }
    };

    const config = {
        lerp: 0.08,
        smoothWheel: true,
        syncTouch: false,
        touchMultiplier: 0,
        infinite: false
    };

    const selectors = {
        popup: '.t-popup_show',
        candidates: ['.t-form__inputsbox', '.t-slds__items-wrapper', '.t-gallery__item-wrapper', '.t-popup__content', '.t-popup__td-content', '.t-popup__container', '.t-rec[data-record-type="604"] .t604__maincontainer'],
        anchors: 'a[href^="#"]',
        wrappers: '.t396__elem[data-elem-type="button"]',
        triggers: ['a[href^="#popup"]', 'a[href^="#order"]', 'div[data-tooltip-hook]', '.js-gallery-zoom-trigger', '.t-submit[href^="#"]', '[data-popup-hook*="#popup"]']
    };

    class TildaController {
        constructor() {
            this.lenis = null;
            this.popups = new Map();
            this.stoppedByPopup = false;
            this.rafId = null;
            this.observer = null;
            this.destroyed = false;
            this.init();
        }

        init() {
            this.lenis = new Lenis(config);
            this.startRAF();
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => this.setup());
            } else {
                this.setup();
            }
        }

        startRAF() {
            const raf = (time) => {
                if (this.destroyed) return;
                this.lenis?.raf(time);
                this.popups.forEach(instance => instance?.raf(time));
                this.rafId = requestAnimationFrame(raf);
            };
            this.rafId = requestAnimationFrame(raf);
        }

        setup() {
            this.reconcilePopups();
            setTimeout(() => this.reconcilePopups(), 500);
            this.setupEvents();
            this.setupObserver();
        }

        setupEvents() {
            document.body.addEventListener('click', (e) => {
                this.handleAnchor(e);
                this.handlePopupTrigger(e);
            }, true);
        }

        handleAnchor(e) {
            const anchor = this.findAnchor(e.target);
            if (!anchor) return;

            const href = anchor.getAttribute('href');
            if (!href) return;

            if (href === '#') {
                e.preventDefault();
                this.lenis?.scrollTo(0);
                window.location.hash = '';
            } else if (href.startsWith('#') && href.length > 1) {
                this.scrollToAnchor(e, href);
            }
        }

        findAnchor(target) {
            let anchor = target.closest(selectors.anchors);
            if (anchor) return anchor;

            const wrapper = target.closest(selectors.wrappers);
            return wrapper?.querySelector(selectors.anchors);
        }

        scrollToAnchor(e, href) {
            e.preventDefault();
            const name = href.substring(1);
            let target = document.querySelector(href) || document.querySelector(`a[name="${name}"]`);
            
            if (!target) {
                const popup = document.querySelector(`[data-tooltip-hook*="${href}"]`) || 
                            document.querySelector(`#rec${name}`) ||
                            document.querySelector(`.t-popup[data-tooltip-hook*="${name}"]`);
                if (popup) return;
            }

            if (target) {
                this.lenis?.scrollTo(target);
                window.location.hash = href;
            }
        }

        handlePopupTrigger(e) {
            const trigger = e.target.closest(selectors.triggers.join(', '));
            if (trigger) {
                setTimeout(() => this.reconcilePopups(), 250);
            }
        }

        setupObserver() {
            this.observer = new MutationObserver(() => this.reconcilePopups());
            this.observer.observe(document.body, {
                attributes: true,
                childList: true,
                subtree: true,
                attributeFilter: ['style', 'class']
            });
        }

        reconcilePopups() {
            if (this.destroyed) return;
            this.cleanupPopups();
            this.createPopups();
            this.manageGlobal();
        }

        cleanupPopups() {
            this.popups.forEach((instance, element) => {
                const popup = element.closest('.t-popup');
                if (!document.body.contains(element) || !popup?.classList.contains('t-popup_show')) {
                    instance?.destroy();
                    this.popups.delete(element);
                }
            });
        }

        createPopups() {
            document.querySelectorAll(selectors.popup).forEach(popup => {
                if (this.hasPopup(popup)) return;
                const scrollable = this.findScrollable(popup);
                if (scrollable) {
                    const options = { 
                        ...config, 
                        lerp: smoothEnabled ? 0.08 : 1, // Balanced lerp for mouse
                        smoothWheel: smoothEnabled 
                    };
                    const instance = new Lenis({ wrapper: scrollable, content: scrollable, ...options });
                    this.popups.set(scrollable, instance);
                }
            });
        }

        findScrollable(popup) {
            for (const sel of selectors.candidates) {
                const candidate = popup.querySelector(sel);
                if (candidate && this.isScrollable(candidate)) return candidate;
                if (candidate) {
                    for (const child of candidate.children) {
                        if (this.isScrollable(child)) return child;
                    }
                }
            }
            return this.isScrollable(popup) ? popup : null;
        }

        isScrollable(el) {
            if (!el) return false;
            const style = getComputedStyle(el);
            return ['scroll', 'auto'].some(v => style.overflowY === v || style.overflowX === v);
        }

        hasPopup(popup) {
            return Array.from(this.popups.keys()).some(el => el === popup || popup.contains(el));
        }

        updatePopups() {
            this.popups.forEach(instance => {
                if (instance?.options) {
                    instance.options.lerp = smoothEnabled ? 0.08 : 1; // Balanced lerp
                    instance.options.smoothWheel = smoothEnabled;
                }
            });
        }

        manageGlobal() {
            const hasPopups = this.popups.size > 0;
            if (hasPopups && !this.stoppedByPopup) {
                this.lenis?.stop();
                this.stoppedByPopup = true;
            } else if (!hasPopups && this.stoppedByPopup) {
                this.lenis?.start();
                this.stoppedByPopup = false;
            }
        }

        destroy() {
            this.destroyed = true;
            if (this.rafId) cancelAnimationFrame(this.rafId);
            this.lenis?.destroy();
            this.popups.forEach(instance => instance?.destroy());
            this.observer?.disconnect();
        }
    }

    // Initialize input detector and controller
    detector.init();
    
    const controller = new TildaController();
    window.TildaController = {
        destroy: () => controller?.destroy(),
        getInstance: () => controller
    };

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => controller?.destroy());

})();
</script> 